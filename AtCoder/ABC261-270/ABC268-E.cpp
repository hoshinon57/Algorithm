#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;
typedef long long ll;
const ll INF64 = 1LL << 60;
const int INF32 = 1 << 30;

// ABC268 https://atcoder.jp/contests/abc268

/*
 * いもす法(のはず)で解く。
 * ※何とか実装しきったが、あまりにも場合分けが多くなってしまった。
 *   ABC268-E-2.cpp, ABC268-E-3.cppの方が良い。
 * 
 * まず、人iに着目して、料理iがどの人の前に置かれているかをidx[]に保持しておく。
 * これを用いて、人iの不満度が0になるには、テーブルを以下の回数回せばよい。
 *   (i-idx[i]+N) mod N
 * 
 * 例えばN=6のとき、テーブルを反時計回りに回転させていくと、不満度は
 *   2, 3, 2, 1, 0, 1, ...
 * のように1ずつ増加 or 減少していく。すると、
 * ・0から1への変化点を+2
 * ・3から2への変化点を-2
 * ・初期状態での変化点は、料理が反時計回り側 or 時計回り側のどちらにあるかによって、+1 or -1
 * のようにいもす法のテーブルが求められる。
 * 
 * ただし初期状態で不満度が0、不満度が最大のときも場合分けが必要。
 * またNが奇数のときは、不満度が最大になる点が2回あり、偶数より場合分けが増える。
 * これらをゴリゴリと実装していく。
 * 
 * いもす法のテーブルを用意したら、
 * 回転テーブルが初期状態のときの不満度を事前計算し、
 * あとはいもす法の「シミュレート」処理を行えばよい。
 * 参考：https://imoz.jp/algorithms/imos_method.html
 */
int main(void)
{
	int i;
	int N;
	cin >> N;
	vector<int> p(N);
	vector<int> idx(N);  // idx[i]:料理iは、どの人の前に置かれているか
	for(i = 0; i < N; i++)
	{
		cin >> p[i];
		idx[p[i]] = i;
	}
	// ここまで入力

	// いもす法における「記録」処理
	vector<ll> imos(N);
	for(i = 0; i < N; i++)  // 各人ごとに、いもす法のテーブルを生成する
	{
		// x:人iの不満度が0になるには(＝目の前に料理が来る)、テーブルを何回回せば良いか
		int x = (i-idx[i]+N)%N;
		// y:人iの不満度が最大になるには、テーブルを何回回せばよいか
		int y = (x+N/2)%N;  // 目の前に来た状態から、1周の半分回せばよい

		// Nが偶奇で処理を分ける
		if(N%2 == 0)
		{
			// xより後は、不満度が増えていく
			// yより後は、不満度が減っていく
			if(x == 0)  // 初期状態で不満度が0
			{
				imos[x+1]++;  // imos[1]
				imos[y+1] -= 2;  // 変化量を-1にしたい。直前まで変化量が+1のため、2減算する
			}
			else if(y == 0)  // 初期状態で不満度が最大
			{
				imos[x+1] += 2;  // 変化量を+1にしたい。直前まで変化量が-1のため、2加算する
				imos[y+1]--;  // imos[1]
			}
			else
			{
				imos[x+1] += 2;
				imos[y+1] -= 2;
				// 最初の変化量、imos[1]を求める
				if(x > y)
				{
					imos[1]++;  // 不満度が増えていく状態から始まる
				}
				else
				{
					imos[1]--;  // 不満度が減っていく状態から始まる
				}
			}
		}
		else
		{
			// 奇数の場合、不満度が最大になるのが2回あり、偶数より場合分けが増える
			if(x == 0)
			{
				imos[x+1]++;  // imos[1]
				imos[y+1]--;  // 変化量を0にしたい。直前まで変化量が+1のため、1減算する
				imos[y+2]--;  // 変化量を-1にしたい
			}
			else if(y == 0)  // 初期状態で不満度が最大 Nが奇数なので、1回回した後も不満度は変わらず最大
			{
				imos[x+1] += 2;
				// imos[y+1];  // imos[1] 変化量は0
				imos[y+2]--;
			}
			else if(y+1 == 0)  // 初期状態で不満度が最大
			{
				imos[x+1] += 2;
				// imos[y+1];
				imos[y+2]--;  // imos[1]
			}
			else
			{
				imos[x+1] += 2;
				imos[y+1]--;
				imos[y+2]--;
				if(x > y)
				{
					imos[1]++;
				}
				else
				{
					imos[1]--;
				}
			}
		}
	}

	// テーブルが初期状態のときの不満度を事前計算する
	ll fuman = 0;
	for(i = 0; i < N; i++)  // 人iの不満度
	{
		fuman += min((i-idx[i]+N)%N, (idx[i]-i+N)%N);  // 料理が反時計回り側と時計回り側とで、近い方の距離が不満度になる
	}

	// いもす法における「シミュレート」処理
	ll answer = fuman;
	for(i = 1; i < N; i++)  // 回転をi回実施
	{
		imos[i] += imos[i-1];  // i回目の回転を行ったときの、不満度の変化量
		fuman += imos[i];
		answer = min(answer, fuman);
	}
	cout << answer << endl;

	return 0;
}
